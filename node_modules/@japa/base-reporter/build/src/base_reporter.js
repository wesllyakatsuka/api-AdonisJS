"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseReporter = void 0;
const ms_1 = __importDefault(require("ms"));
const cliui_1 = require("@poppinss/cliui");
const errors_printer_1 = require("@japa/errors-printer");
class BaseReporter {
    options;
    runner;
    currentFileName;
    currentSuiteName;
    uncaughtExceptions = [];
    constructor(options = {}) {
        this.options = {
            stackLinesCount: options.stackLinesCount || 5,
        };
    }
    printAggregate(label, count, whitespaceLength) {
        if (count) {
            console.log(cliui_1.logger.colors.dim(`${label.padEnd(whitespaceLength + 2)} : ${count}`));
        }
    }
    onTestStart(_) { }
    onTestEnd(_) { }
    onGroupStart(_) { }
    onGroupEnd(_) { }
    onSuiteStart(_) { }
    onSuiteEnd(_) { }
    async start(_) { }
    async end(_) { }
    async printSummary(summary) {
        console.log('');
        if (summary.aggregates.total === 0 && !summary.hasError) {
            console.log(cliui_1.logger.colors.bgYellow().black(' NO TESTS EXECUTED '));
            return;
        }
        if (summary.hasError) {
            console.log(cliui_1.logger.colors.bgRed().black(' FAILED '));
        }
        else {
            console.log(cliui_1.logger.colors.bgGreen().black(' PASSED '));
        }
        console.log('');
        const aggregatesWhiteSpace = summary.aggregates.uncaughtExceptions ? 19 : 10;
        this.printAggregate('total', summary.aggregates.total, aggregatesWhiteSpace);
        this.printAggregate('failed', summary.aggregates.failed, aggregatesWhiteSpace);
        this.printAggregate('passed', summary.aggregates.passed, aggregatesWhiteSpace);
        this.printAggregate('todo', summary.aggregates.todo, aggregatesWhiteSpace);
        this.printAggregate('skipped', summary.aggregates.skipped, aggregatesWhiteSpace);
        this.printAggregate('regression', summary.aggregates.regression, aggregatesWhiteSpace);
        this.printAggregate('uncaught exceptions', summary.aggregates.uncaughtExceptions, aggregatesWhiteSpace);
        this.printAggregate('duration', (0, ms_1.default)(summary.duration), aggregatesWhiteSpace);
        if (summary.failureTree.length || this.uncaughtExceptions.length) {
            console.log('');
            console.log('');
        }
        const errorPrinter = new errors_printer_1.ErrorsPrinter({
            stackLinesCount: this.options.stackLinesCount,
        });
        for (let suite of summary.failureTree) {
            await errorPrinter.printErrors(suite.name, suite.errors);
            for (let testOrGroup of suite.children) {
                if (testOrGroup.type === 'group') {
                    await errorPrinter.printErrors(testOrGroup.name, testOrGroup.errors);
                    for (let test of testOrGroup.children) {
                        await errorPrinter.printErrors(test.title, test.errors);
                    }
                }
                else {
                    await errorPrinter.printErrors(testOrGroup.title, testOrGroup.errors);
                }
            }
        }
        await errorPrinter.printErrors('Uncaught exception', this.uncaughtExceptions);
    }
    boot(runner, emitter) {
        this.runner = runner;
        emitter.on('test:start', (payload) => {
            this.currentFileName = payload.meta.fileName;
            this.onTestStart(payload);
        });
        emitter.on('test:end', (payload) => {
            this.onTestEnd(payload);
        });
        emitter.on('group:start', (payload) => {
            this.currentFileName = payload.meta.fileName;
            this.onGroupStart(payload);
        });
        emitter.on('group:end', (payload) => {
            this.onGroupEnd(payload);
        });
        emitter.on('suite:start', (payload) => {
            this.currentSuiteName = payload.name;
            this.onSuiteStart(payload);
        });
        emitter.on('suite:end', (payload) => {
            this.currentSuiteName = undefined;
            this.onSuiteEnd(payload);
        });
        emitter.on('uncaught:exception', async (error) => {
            this.uncaughtExceptions.push({ phase: 'test', error });
        });
        emitter.on('runner:start', async (payload) => {
            await this.start(payload);
        });
        emitter.on('runner:end', async (payload) => {
            await this.end(payload);
        });
    }
}
exports.BaseReporter = BaseReporter;
